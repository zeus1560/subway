<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>서울 지하철 경로 찾기</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .animate-spin {
      animation: spin 1s linear infinite;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useMemo, useEffect, useCallback } = React;

    // ========== 설정 ==========
    // API 서버 URL을 여기에 설정하세요 (예: 'http://localhost:4000/api/route')
    const API_BASE_URL = window.location.origin + '/api/route';
    // 또는 직접 URL 지정: const API_BASE_URL = 'https://your-api-server.com/api/route';

    // ========== 유틸리티 함수 ==========
    function safeMinutes(v) {
      const n = Number(v);
      return Number.isFinite(n) && n > 0 ? n : null;
    }

    function safeFare(v) {
      const n = Number(v);
      return Number.isFinite(n) && n >= 0 ? n : null;
    }

    function getLineColor(line) {
      const lineColors = {
        '1': '#0052A4',
        '2': '#00A84D',
        '3': '#EF7C1C',
        '4': '#00A5DE',
        '5': '#996CAC',
        '6': '#CD7C2F',
        '7': '#747F00',
        '8': '#E6186C',
        '9': '#BDB092',
      };
      return lineColors[line] || '#666666';
    }

    // ========== 경로 정규화 함수 ==========
    function buildSummarySubPaths(rawSubPath) {
      if (!Array.isArray(rawSubPath) || rawSubPath.length === 0) {
        return [];
      }

      let totalWalk = 0;
      const transitSegments = [];

      rawSubPath.forEach((sp) => {
        if (!sp || typeof sp !== 'object') {
          return;
        }

        const rawMinutes = sp.sectionTime ? Math.round(sp.sectionTime / 60) : null;
        const minutes = safeMinutes(rawMinutes);
        const t = sp.trafficType;

        if (t === 3) {
          if (minutes != null) {
            totalWalk += minutes;
          }
          return;
        }

        if (t === 1) {
          const lane = sp.lane?.[0];
          let label = "지하철";
          
          if (lane) {
            if (lane.name) {
              const nameStr = String(lane.name).trim();
              label = nameStr.length > 0 ? nameStr : "지하철";
            }
          }
          
          if ((label && label.trim().length > 0) || minutes != null) {
            transitSegments.push({
              type: "subway",
              label: (label && label.trim().length > 0) ? label : "지하철",
              minutes,
            });
          }
        } else if (t === 2) {
          const lane = sp.lane?.[0];
          let label = "버스";
          
          if (lane && lane.busNo) {
            const busNo = String(lane.busNo).trim();
            label = busNo.length > 0 ? `버스 ${busNo}` : "버스";
          }
          
          transitSegments.push({
            type: "bus",
            label,
            minutes,
          });
        }
      });

      const result = [];

      if (totalWalk > 0) {
        result.push({
          type: "walk",
          label: "도보",
          minutes: totalWalk,
        });
      }

      transitSegments.forEach((seg) => {
        if (!seg.label || seg.label.trim().length === 0) {
          return;
        }

        const last = result[result.length - 1];
        if (last && last.type === seg.type && last.label === seg.label) {
          const a = last.minutes ?? 0;
          const b = seg.minutes ?? 0;
          const sum = a + b;
          last.minutes = Number.isFinite(sum) && sum > 0 ? sum : last.minutes;
        } else {
          result.push(seg);
        }
      });

      return result;
    }

    function buildSummarySubPathsFromSegments(segments) {
      if (!Array.isArray(segments) || segments.length === 0) {
        return [];
      }

      let totalWalk = 0;
      const transitSegments = [];

      segments.forEach((seg) => {
        if (!seg || typeof seg !== 'object') {
          return;
        }

        const minutes = safeMinutes(seg.durationMinutes ?? seg.travelTime ?? seg.minutes ?? seg.segmentMinutes);
        const rawLine = seg.line;
        
        let lineStr = '';
        if (rawLine != null) {
          if (typeof rawLine === 'number') {
            lineStr = String(rawLine);
          } else if (typeof rawLine === 'string') {
            lineStr = rawLine.trim();
          } else {
            lineStr = String(rawLine).trim();
          }
        }
        
        if (lineStr === '도보' || lineStr === '' || lineStr === 'undefined' || lineStr === 'null') {
          if (minutes != null) {
            totalWalk += minutes;
          }
          return;
        }
        
        let type;
        let label;
        
        if (lineStr.toLowerCase().includes('버스') || lineStr.toLowerCase().startsWith('bus')) {
          type = "bus";
          label = lineStr.includes('버스') ? lineStr : `버스 ${lineStr}`;
        } else {
          type = "subway";
          const lineNum = lineStr.replace(/호선/g, '').replace(/[^0-9]/g, '').trim();
          if (lineNum.length > 0) {
            label = `${lineNum}호선`;
          } else {
            label = lineStr.length > 0 ? lineStr : "지하철";
          }
        }
        
        if (label && label.length > 0 && label !== "지하철") {
          transitSegments.push({
            type,
            label,
            minutes,
            stationCount: typeof seg.stationCount === 'number' ? seg.stationCount : undefined,
          });
        }
      });

      const result = [];

      if (totalWalk > 0) {
        result.push({
          type: "walk",
          label: "도보",
          minutes: totalWalk,
        });
      }

      transitSegments.forEach((seg) => {
        if (!seg.label || seg.label.trim().length === 0) {
          return;
        }

        const last = result[result.length - 1];
        if (last && last.type === seg.type && last.label === seg.label) {
          const a = last.minutes ?? 0;
          const b = seg.minutes ?? 0;
          const sum = a + b;
          last.minutes = Number.isFinite(sum) && sum > 0 ? sum : last.minutes;
          
          if (seg.stationCount != null) {
            last.stationCount = (last.stationCount ?? 0) + seg.stationCount;
          }
        } else {
          result.push(seg);
        }
      });

      return result;
    }

    function normalizeRoute(raw, index) {
      const totalMinutes = safeMinutes(raw.totalTravelMinutes ?? raw.travelTime);
      const fare = safeFare(raw.fare);
      const transfers = typeof raw.transfers === 'number' && raw.transfers >= 0 ? raw.transfers : 0;
      const segments = raw.detail?.perSegment || [];
      
      let subPaths = [];
      
      if (raw.rawSubPath && Array.isArray(raw.rawSubPath) && raw.rawSubPath.length > 0) {
        subPaths = buildSummarySubPaths(raw.rawSubPath);
      } else {
        subPaths = buildSummarySubPathsFromSegments(segments);
      }
      
      const stations = [];
      
      if (raw.stations && Array.isArray(raw.stations) && raw.stations.length > 0) {
        raw.stations.forEach((stationName) => {
          if (stationName) {
            stations.push({ name: stationName });
          }
        });
      } else {
        if (segments.length > 0) {
          if (segments[0].from) {
            stations.push({ name: segments[0].from });
          }
          
          for (let i = 0; i < segments.length - 1; i++) {
            const current = segments[i];
            const next = segments[i + 1];
            
            if (current.to === next.from && current.to) {
              const exists = stations.some(s => s.name === current.to);
              if (!exists) {
                stations.push({ name: current.to });
              }
            }
          }
          
          const lastSegment = segments[segments.length - 1];
          if (lastSegment.to) {
            const exists = stations.some(s => s.name === lastSegment.to);
            if (!exists) {
              stations.push({ name: lastSegment.to });
            }
          }
        }
      }
      
      const id = `naver-${index}`;
      const isBest = index === 0;
      
      return {
        id,
        totalMinutes,
        fare,
        transfers,
        isBest,
        subPaths,
        stations,
      };
    }

    // ========== 아이콘 컴포넌트 ==========
    function SearchIcon({ className = "w-6 h-6" }) {
      return (
        <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
      );
    }

    function MapPinIcon({ className = "w-5 h-5", color = "currentColor" }) {
      return (
        <svg className={className} fill="none" stroke={color} viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
        </svg>
      );
    }

    function CalendarIcon({ className = "w-5 h-5" }) {
      return (
        <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
        </svg>
      );
    }

    function LoaderIcon({ className = "w-8 h-8" }) {
      return (
        <svg className={className + " animate-spin"} fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      );
    }

    // ========== 컴포넌트 ==========
    function LoadingSpinner() {
      return (
        <div className="flex flex-col items-center justify-center" role="status" aria-live="polite" aria-label="로딩 중">
          <LoaderIcon className="text-blue-500" />
          <span className="sr-only">로딩 중입니다</span>
        </div>
      );
    }

    function RouteResultCard({ route, index }) {
      const { totalMinutes, fare, transfers, isBest, subPaths, stations } = route;
      
      const totalLabel = totalMinutes != null ? `${totalMinutes}분` : "시간 정보 없음";
      const fareLabel = fare != null ? `${fare.toLocaleString()}원` : null;

      return (
        <div
          className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-xl p-6"
          style={{
            borderColor: isBest ? "#60a5fa" : undefined,
            borderWidth: isBest ? 2 : 1,
          }}
        >
          <div className="flex items-center justify-between mb-4 pb-4 border-b border-gray-200 dark:border-gray-700">
            <div className="flex items-center gap-3">
              {isBest && (
                <span className="text-xs font-bold px-2 py-1 bg-blue-500 text-white rounded">
                  최적
                </span>
              )}
              <div>
                <div className="text-lg font-bold text-gray-900 dark:text-white">
                  {totalLabel}
                </div>
                {fareLabel && (
                  <div className="text-sm text-gray-600 dark:text-gray-400">
                    {fareLabel}
                  </div>
                )}
                {transfers > 0 && (
                  <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                    환승 {transfers}회
                  </div>
                )}
              </div>
            </div>

            {subPaths.length > 0 && (
              <div className="flex items-center gap-2 flex-nowrap overflow-x-auto max-w-[420px]">
                {subPaths.map((sp, i) => {
                  const minutes = sp.minutes;
                  const timeText = minutes != null ? `${minutes}분` : "정보 없음";
                  
                  const rawLabel = sp.label;
                  const displayLabel = (rawLabel && typeof rawLabel === 'string' && rawLabel.trim().length > 0)
                    ? rawLabel.trim()
                    : "구간";
                  
                  let bgClass = "bg-amber-200 text-gray-900";
                  if (sp.type === "subway") {
                    const lineNum = displayLabel.replace("호선", "").trim();
                    const lineColor = getLineColor(lineNum);
                    return (
                      <span
                        key={i}
                        className="px-3 py-1.5 rounded-full text-xs font-semibold whitespace-nowrap"
                        style={{
                          backgroundColor: lineColor,
                          color: "#ffffff",
                        }}
                      >
                        {displayLabel} {timeText}
                      </span>
                    );
                  } else if (sp.type === "bus") {
                    bgClass = "bg-emerald-200 text-gray-900";
                  }
                  
                  return (
                    <span
                      key={i}
                      className={`px-3 py-1.5 rounded-full text-xs font-semibold whitespace-nowrap ${bgClass}`}
                    >
                      {displayLabel} {timeText}
                    </span>
                  );
                })}
              </div>
            )}
          </div>

          {stations.length > 0 && (
            <div className="space-y-2">
              {stations.map((st, i) => (
                <div
                  key={`${st.name}-${i}`}
                  className="flex items-center gap-2 text-sm text-gray-700 dark:text-gray-300"
                >
                  <div className="w-1 h-1 rounded-full bg-gray-500 flex-shrink-0" />
                  <span>{st.name}</span>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    function BottomNavigation() {
      return (
        <nav className="fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-900 border-t border-gray-200 dark:border-gray-800 z-50">
          <div className="container mx-auto px-4 py-2">
            <div className="flex justify-around">
              <div className="flex flex-col items-center gap-1 py-2 px-4 text-blue-500">
                <SearchIcon className="w-6 h-6" />
                <span className="text-xs font-medium">경로 찾기</span>
              </div>
            </div>
          </div>
        </nav>
      );
    }

    // ========== 메인 컴포넌트 ==========
    function RoutePage() {
      const [startStation, setStartStation] = useState('');
      const [endStation, setEndStation] = useState('');
      const [routes, setRoutes] = useState([]);
      const [loading, setLoading] = useState(false);
      const [departureDateTime, setDepartureDateTime] = useState("");

      const getMinDateTimeString = useCallback(() => {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      }, []);

      const getEffectiveDepartureTime = useCallback(() => {
        if (!departureDateTime || departureDateTime === "") {
          return new Date();
        }
        
        const dt = new Date(departureDateTime);
        const now = new Date();
        
        if (dt.getTime() < now.getTime()) {
          return now;
        }
        
        return dt;
      }, [departureDateTime]);

      const searchRoute = useCallback(async (startStation, endStation) => {
        const startTrimmed = startStation?.trim() || '';
        const endTrimmed = endStation?.trim() || '';
        
        if (!startTrimmed || !endTrimmed) {
          throw new Error('출발역과 도착역을 모두 입력해주세요.');
        }

        const effectiveTime = getEffectiveDepartureTime();
        
        if (departureDateTime && departureDateTime !== "") {
          const selectedTime = new Date(departureDateTime);
          const now = new Date();
          if (selectedTime.getTime() < now.getTime()) {
            setDepartureDateTime("");
          }
        }

        setLoading(true);
        try {
          const response = await fetch(API_BASE_URL, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              startStation: startTrimmed,
              endStation: endTrimmed,
              timestamp: effectiveTime.toISOString(),
            }),
          });
          
          const data = await response.json();
          
          if (!response.ok) {
            const errorMessage = data.error || data.message || `서버 오류 (${response.status})`;
            throw new Error(errorMessage);
          }
          
          if (!data.success || !Array.isArray(data.routes) || data.routes.length === 0) {
            throw new Error(data.message || '경로를 찾을 수 없습니다.');
          }
          
          const results = data.routes;
          setRoutes(results.slice(0, 1));
        } catch (error) {
          console.error('경로 찾기 실패', error);
          throw error;
        } finally {
          setLoading(false);
        }
      }, [departureDateTime, getEffectiveDepartureTime]);

      const normalizedRoutes = useMemo(() => {
        return routes.map((route, index) => normalizeRoute(route, index));
      }, [routes]);
      
      const displayRoutes = useMemo(() => {
        if (normalizedRoutes.length === 0) return [];
        
        return normalizedRoutes.map((r, idx) => ({
          ...r,
          isBest: idx === 0,
        }));
      }, [normalizedRoutes]);

      const handleSearch = async () => {
        if (!startStation.trim() || !endStation.trim()) {
          alert('출발역과 도착역을 모두 입력해주세요.');
          return;
        }
        
        try {
          await searchRoute(startStation.trim(), endStation.trim());
        } catch (error) {
          alert(error.message || '경로를 찾을 수 없습니다.');
        }
      };

      return (
        <div className="min-h-screen bg-white dark:bg-gray-900 pb-20">
          <header className="sticky top-0 z-40 bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-800">
            <div className="container mx-auto px-4 py-4">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-blue-500 rounded-lg flex items-center justify-center">
                  <SearchIcon className="w-6 h-6 text-white" />
                </div>
                <div>
                  <h1 className="text-2xl font-bold text-gray-900 dark:text-white">경로 찾기</h1>
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                    덜 붐비는 환승 루트 추천
                  </p>
                </div>
              </div>
            </div>
          </header>

          <main className="container mx-auto px-4 py-6">
            <div className="space-y-4 mb-6">
              <div className="bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4 space-y-3">
                <div className="flex items-center gap-3">
                  <MapPinIcon className="w-5 h-5 text-blue-500 flex-shrink-0" />
                  <input
                    type="text"
                    placeholder="출발역 입력"
                    value={startStation}
                    onChange={(e) => setStartStation(e.target.value)}
                    className="flex-1 bg-transparent text-gray-900 dark:text-white placeholder-gray-500 focus:outline-none text-base"
                    onKeyDown={(e) => e.key === 'Enter' && handleSearch()}
                  />
                </div>
                <div className="flex items-center gap-3">
                  <MapPinIcon className="w-5 h-5 text-red-500 flex-shrink-0" color="#ef4444" />
                  <input
                    type="text"
                    placeholder="도착역 입력"
                    value={endStation}
                    onChange={(e) => setEndStation(e.target.value)}
                    className="flex-1 bg-transparent text-gray-900 dark:text-white placeholder-gray-500 focus:outline-none text-base"
                    onKeyDown={(e) => e.key === 'Enter' && handleSearch()}
                  />
                </div>
              </div>

              <div className="bg-gray-50 dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                <div className="flex items-center gap-2 mb-2">
                  <CalendarIcon className="w-5 h-5 text-blue-500" />
                  <label className="text-sm font-semibold text-gray-700 dark:text-gray-300">
                    출발 시간
                  </label>
                </div>
                <div className="text-xs text-gray-500 dark:text-gray-400 mb-3">
                  미래 시간만 설정할 수 있습니다. 비워두면 현재 시간 기준으로 예측합니다.
                </div>
                
                <input
                  type="datetime-local"
                  value={departureDateTime}
                  min={getMinDateTimeString()}
                  onChange={(e) => {
                    const value = e.target.value;
                    if (value) {
                      const selectedTime = new Date(value);
                      const now = new Date();
                      if (selectedTime.getTime() < now.getTime()) {
                        alert('과거 시간은 선택할 수 없습니다.');
                        setDepartureDateTime("");
                      } else {
                        setDepartureDateTime(value);
                      }
                    } else {
                      setDepartureDateTime("");
                    }
                  }}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
                
                <div className="mt-3 p-3 bg-gray-100 dark:bg-gray-700/50 rounded-lg">
                  {departureDateTime && departureDateTime !== "" ? (
                    <>
                      <div className="text-xs text-blue-600 dark:text-blue-400 mb-1">설정된 출발 시간</div>
                      <div className="text-sm font-semibold text-gray-900 dark:text-white">
                        {new Date(departureDateTime).toLocaleString('ko-KR', {
                          year: 'numeric',
                          month: 'long',
                          day: 'numeric',
                          hour: '2-digit',
                          minute: '2-digit',
                          weekday: 'short'
                        })}
                        <span className="ml-2 text-xs text-green-600 dark:text-green-400">
                          (미래 예측)
                        </span>
                      </div>
                    </>
                  ) : (
                    <>
                      <div className="text-xs text-gray-600 dark:text-gray-400 mb-1">현재 시간 기준</div>
                      <div className="text-sm font-semibold text-gray-900 dark:text-white">
                        {new Date().toLocaleString('ko-KR', {
                          year: 'numeric',
                          month: 'long',
                          day: 'numeric',
                          hour: '2-digit',
                          minute: '2-digit',
                          weekday: 'short'
                        })}
                        <span className="ml-2 text-xs text-blue-600 dark:text-blue-400">
                          (지금 출발)
                        </span>
                      </div>
                    </>
                  )}
                </div>
              </div>

              <button
                onClick={handleSearch}
                disabled={loading}
                className="w-full bg-blue-500 text-white py-4 rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 font-semibold text-base"
              >
                <SearchIcon className="w-5 h-5" />
                {loading ? '경로 찾는 중...' : '경로 찾기'}
              </button>
            </div>

            {loading && (
              <div className="flex justify-center py-12">
                <LoadingSpinner />
              </div>
            )}

            {!loading && displayRoutes.length > 0 && (
              <div className="space-y-4">
                {displayRoutes.map((route, index) => (
                  <RouteResultCard
                    key={route.id}
                    route={route}
                    index={index}
                  />
                ))}
              </div>
            )}

            {!loading && displayRoutes.length === 0 && startStation && endStation && (
              <div className="text-center py-12">
                <p className="text-gray-500 dark:text-gray-400">
                  경로를 찾을 수 없습니다.
                </p>
              </div>
            )}
          </main>

          <BottomNavigation />
        </div>
      );
    }

    // ========== 앱 렌더링 ==========
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<RoutePage />);
  </script>
</body>
</html>
